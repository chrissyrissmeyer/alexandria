#!/usr/bin/env ruby

puts 'Loading environment...'
require File.expand_path('../../config/environment', __FILE__)
puts "Running in #{Rails.env} mode..."

require 'trollop'

options = Trollop.options do
  opt :data, 'Data file(s)/directory', type: :strings
  opt :format, 'Metadata format (csv, mods, etd, cyl)', type: :string
  opt :metadata, 'Metadata file(s)/directory', type: :strings
  opt :skip, 'Skip the first N records', default: 0
end

require File.expand_path('../../lib/importer', __FILE__)
AdminPolicy.ensure_admin_policy_exists

# lib/exceptions.rb
require 'exceptions'

require 'fileutils'
require 'find'
require 'json'
require 'traject'

metadata_ext = case options[:format]
               when 'csv'
                 '.csv'
               else
                 '.xml'
               end

# For each argument passed to --metadata, if it's a file, add it
# to the array, otherwise drill down and add each file within to
# the array
meta = if options[:metadata]
         options[:metadata].map do |arg|
           if File.file?(arg)
             arg
           else
             next unless Dir.exist?(arg)
             files = []
             Find.find(arg) do |path|
               next unless File.extname(path) == metadata_ext
               files << path
             end
             files
           end
         end.flatten
       else
         []
       end
# For each argument passed to --data, if it's a file, add it to
# the array, otherwise drill down and add each file within to the
# array
data = if options[:data]
         options[:data].map do |arg|
           if File.file?(arg)
             arg
           else
             next unless Dir.exist?(arg)
             datas = []
             Find.find(arg) do |path|
               next if File.directory?(path)
               datas << path
             end
             datas
           end
         end.flatten
       else
         []
       end

######################
# Begin ingest process
######################
begin
  case options[:format]
  when 'csv'
    meta.each do |m|
      head, tail = Importer::CSV.split(m)

      if options[:skip] >= tail.length
        raise ArgumentError, "Number of records skipped (#{options[:skip]}) greater than total records to ingest"
      end

      tail.each_with_index do |row, count|
        next if options[:skip] > count

        attrs = Importer::CSV.csv_attributes(head, row)
        files = if attrs[:files].nil?
                  []
                else
                  data.select { |d| attrs[:files].include? File.basename(d) }
                end
        begin
          Importer::CSV.import(
            attributes: attrs,
            files: files
          )
          puts "Ingested #{count + 1} of #{tail.length} records"
        # Other exceptions are already handled in CSV.import
        rescue => e
          puts e
          puts e.backtrace
          raise IngestError.new(reached: count)
        rescue Interrupt
          puts "\nIngest stopped, cleaning up..."
          raise IngestError.new(reached: count)
        end
      end
    end
    exit 0
  when 'mods'
    if options[:skip] >= meta.length
      raise ArgumentError, "Number of records skipped (#{options[:skip]}) greater than total records to ingest"
    end

    # TODO: this currently assumes one record per metadata file
    meta.each_with_index do |m, count|
      next if options[:skip] > count

      d = data.select do |f|
        # FIXME: find a more reliable test
        meta_base = File.basename(m, '.xml')
        data_base = File.basename(f, File.extname(f))
        data_base.include?(meta_base) || meta_base.include?(data_base)
      end

      begin
        Importer::Mods.import(m, d)
        puts "Ingested #{count + 1} of #{meta.length} records"
      rescue => e
        puts e
        puts e.backtrace
        raise IngestError.new(reached: count)
      rescue Interrupt
        puts "\nIngest stopped, cleaning up..."
        raise IngestError.new(reached: count)
      end
    end
    exit 0
  when 'etd'
    # lib/proquest
    require 'proquest'

    [Settings.download_root,
     Settings.marc_directory,
     Settings.proquest_directory].each do |dir|
      FileUtils.mkdir_p dir unless Pathname.new(dir).exist?
    end

    if data.empty?
      $stderr.puts 'Nothing found in the data path you specified.'
      exit 1
    end

    Dir.mktmpdir do |temp|
      etds = data.map.with_index do |zip, i|
        # Don't unzip ETDs we won't use
        if i >= options[:skip]
          Proquest.extract(zip, "#{temp}/#{File.basename(zip)}")
        end
      end.compact

      if etds.empty?
        raise ArgumentError, "Number of records skipped (#{options[:skip]}) greater than total records to ingest"
      end

      xml = etds.map { |e| e[:xml] }
      marc = MARC::XMLReader.new(
        StringIO.new(Importer::ETD.fetch_marc(xml))
      )

      marc.each_with_index do |record, count|
        # https://github.com/traject/traject/blob/master/lib/traject/indexer.rb#L101
        indexer = Traject::Indexer.new
        indexer.load_config_file('lib/traject/etd_config.rb')
        indexer.settings(etd: etds[count])

        begin
          indexer.writer.put indexer.map_record(record)
          # Since earlier we skipped the unzip operations we don't
          # need, the array of records to iterate over is smaller, so
          # we modify the numbers here so that we still get the
          # correct "Ingested X of out Y records" readout.
          puts "Ingested #{count + 1 + options[:skip]} of #{etds.length + options[:skip]} records"
        rescue => e
          puts e
          puts e.backtrace
          raise IngestError.new(reached: count)
        rescue Interrupt
          puts "\nIngest stopped, cleaning up..."
          raise IngestError.new(reached: count)
        end
      end
    end
    exit 0
  when 'cyl'
    # XMLReader's Enumerable methods are destructive, so move the
    # MARC::Records to an array so we can measure them:
    # https://github.com/ruby-marc/ruby-marc/pull/47
    marcs = meta.map do |m|
      MARC::XMLReader.new(m).map { |o| o }
    end.flatten

    cylinders = marcs.length

    if options[:skip] >= cylinders
      raise ArgumentError, "Number of records skipped (#{options[:skip]}) greater than total records to ingest"
    end

    marcs.each_with_index do |record, count|
      next if options[:skip] > count

      # https://github.com/traject/traject/blob/master/lib/traject/indexer.rb#L101
      indexer = Traject::Indexer.new
      indexer.load_config_file('lib/traject/audio_config.rb')
      indexer.settings(cylinders: data)

      begin
        indexer.writer.put indexer.map_record(record)
        puts "Ingested #{count + 1} of #{cylinders} records"
      rescue => e
        puts e
        puts e.backtrace
        raise IngestError.new(reached: count)
      rescue Interrupt
        puts "\nIngest stopped, cleaning up..."
        raise IngestError.new(reached: count)
      end
    end
    exit 0
  end
rescue IngestError => e
  puts
  puts "Managed to ingest #{e.reached} objects."
  puts
  puts "To continue this ingest, re-run the command with `--skip #{e.reached}`"
end
